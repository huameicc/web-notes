## 二分查找
### 复杂度 O(logn)

### 思路1
N个数的二分查找，每次退化为N/2或(N-1)/2, 需总计进行x次退化后变为1个数。  
　　1.假设N=2^n，那么刚好有x=log2(N)=n， (n为正整数)  
　　2.假设N=2^(n-1), 则有x=log2(N)=n-1  
　　3.当N介于两者之间时，必然会出现(N-1)/2的退化，最终x=n-1=Floor(log2(N))   
　　　　关于退化次数x也可以这么看：   
　　　　N可分解为: N=a_0\*2^0 + a_1\*2^1 + .. + 2^(n-1);  (a_i in [0, 1])   
　　　　每次退化有: N_next = a_1\*2^0 + .. + 2^(n-2);   
　　　　...   
　　　　所以决定退化次数的只有最后一项 2^(n-1), 即x=n-1=Floor(log2(N))   
　　4.结论是x=Floor(log2(N)) 

而退化为1后仍需要猜测一次所以，查找次数 m=Floor(log2(N))+1

从算法复杂度角度来讲，看退化次数x或者查找次数m都是一样的。

### 思路2
《算法图解》的说明，100每次去除50， 25，13，7，4，2，1感觉不够准确；即使按去除来看，也应该是50，25，13，6，3， 2，1

### 算法思路
数组list，value  
start, end, mid

冒泡： 两两比较，大的移到后面； 短冒泡：一次循环没有数据交换，则已经有序；

选择排序：遍历完一次循环，再交换，减少交换次数。

插入排序：在一端维护有序表，其他数据依次比较找到合适位置插入。

快速排序：取一个基准值（最简单的是取第一个），分割列表，一边都是大的，一边都是小的。（左右标记位，左边找到大于他的停止，右边找到小于他的停止；两者交换元素，继续寻找，直到左右标记位会和，分割完成；然后对左右分别再做快排即可）