## 二分查找
### 复杂度 O(logn)

### 思路1
N个数的二分查找，每次退化为N/2或(N-1)/2, 需总计进行x次退化后变为1个数。  
　　1.假设N=2^n，那么刚好有x=log2(N)=n， (n为正整数)  
　　2.假设N=2^(n-1), 则有x=log2(N)=n-1  
　　3.当N介于两者之间时，必然会出现(N-1)/2的退化，最终x=n-1=Floor(log2(N))   
　　　　关于退化次数x也可以这么看：   
　　　　N可分解为: N=a_0\*2^0 + a_1*2^1 + .. + 2^(n-1);  (a_i in [0, 1])   
　　　　每次退化有: N_next = a_1*2^0 + .. + 2^(n-2);   
　　　　...   
　　　　所以决定退化次数的只有最后一项 2^(n-1), 即x=n-1=Floor(log2(N))   
　　4.结论是x=Floor(log2(N)) 

而退化为1后仍需要猜测一次所以，查找次数 m=Floor(log2(N))+1

从算法复杂度角度来讲，看退化次数x或者查找次数m都是一样的。

### 思路2
《算法图解》的说明，100每次去除50， 25，13，7，4，2，1感觉不够准确；即使按去除来看，也应该是50，25，13，6，3， 2，1

### 算法思路
数组list，value  
start, end, mid

